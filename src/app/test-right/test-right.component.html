<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- CSS only -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

</head>
<body>
    <h1>Test-right, welcome, {{master}}</h1>


    <!-- Aqui, podemos mapear os eventos que acontecem com os elementos -->
    <!-- No caso do botão, o (click) irá chamar o "onClick()" definido lá no component -->
    <button (click)="onClick($event)" class="btn-primary">Greet</button>
    <!-- O valor de "greetings" é definido dentro do método "onClick() no component" -->
    <p>{{greetings}}</p>

    <!-- Essa é uma outra forma de alterar o conteúdo através dos eventos -->
    <button (click)="greetings='Welcome Gabriel'" class="btn-warning" >Welcome</button>


    <!-- Ao colocar o #nome, podemos referenciar o objeto dentro do html e usar algumas propriedades -->
    <br><input #logInput type="text">
    <!-- Nesse caso, estamos usando o atributo value do input e passando ele para o método no component-->
    <button (click)="logMessage(logInput.value)" class="btn-danger">Log</button>
    <br><br><br>

    <!-- Essa forma tem o propósito de manter a View e o Model sempre em sincronia -->    
    <!-- Com isso é possivel manter em sincronia o que está escrito no input com o texto ao lado -->
    <!-- A sintaxe é [(ngmodel)]="nome_da_variavel_no_component" -->
    <!-- Assim, o value do input, vai pra class propriety(component) e depois o value que foi pro component vai de volta pro {{name}} -->
    <input [(ngModel)]="name" type="text">
    {{name}}
   

</body>
</html>